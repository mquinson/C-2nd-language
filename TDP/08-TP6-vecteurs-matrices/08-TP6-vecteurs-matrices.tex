\documentclass[10pt]{article}\usepackage[enonce]{exemptty}

%\usepackage{exercices}[correction]
%\usepackage[hidelinks]{hyperref}
%\usepackage{../exercices}
%\usepackage{color}
\usepackage{booktabs}

\newcommand{\I}{\hspace{1.5em}}

\title{Allocation de tableaux en C}
\TDnumber{0}
\TDmodule{}%Module ArcSys}

% Pour l'année prochaine :
% - Améliorer le makefile pour un meilleur affichage de succès/failure
% - Supprimer des headers le fait de renvoyer NULL pour les allocations invalide (on appelle abort() jamais autre chose
% !!)

\begin{document}

\maketitle

\noindent\framebox{\begin{minipage}{.95\linewidth}
    \noindent\textbf{\large Objectifs pédagogiques:}
    \begin{itemize}
    \item[$\bullet$] Allouer/libérer de la mémoire avec \lstinline$malloc$/\lstinline$free$;
    \item[$\bullet$] Manipuler des pointeurs/tableaux;
    \item[$\bullet$] Créer de nouveaux types de données;
    \item[$\bullet$] Utiliser en pratique les outils gdb et valgrind.
    \end{itemize}
\end{minipage}}\medskip

L'objectif de ce TP est de manipuler les fonctions \lstinline$malloc$
et \lstinline$free$, et de vous entrainer à debugger un programme
s'arrêtant sur SEGFAULT. L'excuse du jour sera la création d'une
bibliothèque permettant de créer et manipuler des vecteurs et des
matrices.  \bigskip

\PseudoExo{Principe du TP.} 
Veuillez télécharger l'archive :\\
\url{http://people.irisa.fr/Martin.Quinson/Teaching/ArcSys/99-allocation-tableaux.tar.gz}

Vous trouverez dans cette archive plusieurs programmes à compléter. Vous pouvez
compiler et tester tous les exercices de la séance avec la commande \run{make
  test}

Chaque test correspond à un programme (le nom du programme s'affiche avant
ECHEC ou SUCCES) que vous pouvez exécuter indépendemment pour déterminer vos
erreurs. Le test \texttt{$<$toto$>$} est passé si votre programme \texttt{toto}
affiche exactement la même chose que ce qui se trouve dans le fichier
\texttt{toto.result}. N'hésitez pas à consulter le contenu des fichiers fournis
pour comprendre le fonctionnement de l'ensemble. Si votre programme vous semble
fonctionner, mais que la suite de tests vous indique le contraire, comparez le
contenu du fichier \texttt{toto.output} produit par votre programme au fichier
\texttt{toto.result}, qui est la sortie attendue par la suite de tests. Pour
cela, vous pouvez utiliser la commande

\noindent\run{diff -u toto.result toto.output}
qui affiche les différences ligne par ligne. Il est bien entendu possible de
modifier \texttt{toto.result} pour faire en sorte que les tests ne détectent
plus le problème, mais ce n'est pas l'objectif ;)

Pour comprendre votre segfault, utilisez valgrind en exécutant:
\run{valgrind --leak-check=full ./toto}

\begin{Exercice} \textbf{Vecteurs.}
  Nous souhaitons réaliser les fonctions nécessaires à la gestion d'un type
  vecteur.

  \Question Complétez \file{vecteur.c} qui contient toutes les
  fonctions de gestion de vecteur que nous voulons implémenter. Le
  fichier \file{vecteur.h} contient toutes les informations
  nécessaires : description des fonctions et déclaration du type
  vecteur. Une fois toutes les fonctions complétées, tapez \run{make
    t00-vector} pour compiler, \run{./t00-vector} pour exécuter le
  programme de test et make test pour tester si le résultat du
  programme de test est correct (s'il affiche la même chose que ce qui
  se trouve dans \file{t00-vector.result}).

  \Question Ajoutez un test dans la fonction d'accès, et renvoyez NULL
  si l'indice demandé est en dehors des bornes de l'objet
  concerné. Testez votre modification avec le programme
  \run{./t01-vector-bound}

  \Question On a supposé à la question précédente qu'accéder à une
  case inexistante est une erreur. Parfois, on préfère faire en sorte
  que le vecteur grandisse automatiquement pour créer à la demande les
  cases inexistantes. Comme il est difficile de prédire le
  comportement souhaité par l'utilisateur de la bibliothèque, on va
  configurer le comportement avec le champ \texttt{dynamique} de la
  structure vecteur. S'il vaut FAUX (\texttt{dynamique == 0}), on
  utilisera le comportement de la question précédente: un accès à une
  case inexistante renvoi NULL. Si le champ vaut VRAI
  (\texttt{dynamique != 0}), il faut agrandir le tableau (avec
  \texttt{realloc}) quand l'indice dépasse la borne.

  Testez votre modification avec le programme \run{./t02-vector-realloc}.
\end{Exercice}

\begin{Exercice} \textbf{Matrices.}  Complétez le fichier
  \file{matrice.c} pour la gestion d'un type \texttt{matrice\_t},
  représenté ainsi:
  
  \smallskip\noindent
  \begin{minipage}{.5\linewidth}%

    ~~Pour allouer une telle structure, on alloue d'abord un tableau de
    pointeurs, dont la taille correspond au nombre de lignes
    souhaité. Ensuite, chacune des cases de ce premier tableau est un
    pointeur vers un autre tableau alloué séparément pour représenter
    l'une des lignes. Le code correspondant est donné page suivante.

    \smallskip
    ~~On accède ensuite aux cases du tableaux comme on le ferait pour un
    tableau alloué statiquement: avec l'opérateur \verb~[ ]~ pour
    chacune des dimensions:

\begin{Verbatim}[label=Initialisation des éléments,numbers=right]    
for (int i = 0; i < 10; i++)
    for (int j = 0; j < 10; j++)
        tableau[i][j] = 0;
\end{Verbatim}


  % La seule
%   différence avec un tableau alloué de manière statique est le type des objets
%   manipulés : dans le cas dynamique ce sera un tableau de pointeurs, dans le
%   cas statique ce sera un tableau de tableaux (les tableaux sont réellement
%   stockés les uns après les autres en mémoire).
% ;
\end{minipage}\hfill\begin{minipage}{.48\linewidth}
  \includegraphics[width=\linewidth]{tableau.pdf}
\end{minipage}
  
\begin{Verbatim}[label=Allocation d'un tableau de 10*10 doubles]
double** tableau;

tableau = malloc(sizeof(double*) * 10);
for (int i = 0; i < 10; i++) {
    tableau[i] = malloc(sizeof(double) * 10);
}
\end{Verbatim}

\begin{Verbatim}[label=Idem avec gestion des erreurs]
double** tableau;

tableau = malloc(sizeof(double *) * 10);
if (tableau == NULL) { // malloc signale une erreur
    abort(); // tue le programme en signalant un bug interne
}
for (int i = 0; i < 10; i++) {
    tableau[i] = malloc(sizeof(double) * 10);
    if (tableau[i] == NULL) {
        abort();
    }
}
\end{Verbatim}


  \Question Complétez le fichier \file{matrice.c} qui contient toutes les
  fonctions de gestion de matrice que nous voulons implémenter. Le fichier
  \file{matrice.h} contient toutes les informations nécessaires : description
  des fonctions et déclaration du type matrice. Une fois les fonctions
  complétées, tapez \run{make t10-matrix} pour compiler,
  \run{./make t10-matrix} pour exécuter le programme de test et \run{make
    test} pour tester si le résultat du programme de test est correct.
\end{Exercice}


\medskip





\begin{Exercice} \textbf{Matrices linéaires (optionnel)} 

  Nous souhaitons réaliser les fonctions nécessaires à la gestion d'un type
  matrice, où les matrices sont représentées par un seul tableau
  unidimensionel. Dans ce cas, les lignes de la matrice sont stockées les unes
  après les autres et la fonction d'accès va devoir faire la traduction d'un
  couple d'indices vers un unique indice dans le tableau (l'avantage est que
  l'on économise une indirection ainsi que le coût des structures de gestion
  mémoire associées à chaque \texttt{malloc} par le système). La figure
  suivante décrit l'organisation de nos matrices en mémoire :

  \centerline{\includegraphics[width=\linewidth]{tableau-lineaire.pdf}}

  Complétez le fichier \file{matrice\_lineaire.c} qui contient toutes les
  fonctions de gestion de matrice que nous voulons implémenter. Le fichier
  \file{matrice\_lineaire.h} contient toutes les informations nécessaires :
  description des fonctions et déclaration du type matrice. Une fois les
  fonctions complétées, tapez
  
  \noindent\run{make matrice\_lineaire\_testbase} pour
  compiler, \run{./matrice\_lineaire\_testbase} pour exécuter le programme de
  test et \run{make test} pour tester si le résultat du programme de test est
  correct.
\end{Exercice}

\begin{Exercice} \textbf{Vérifier les bornes (optionnel)}

  Reprenez les trois exercices précédents en ajoutant un test dans la fonction
  d'accès permettant de renvoyer NULL si les indices demandés sont en dehors
  des bornes de l'objet concerné.
\end{Exercice}

\begin{Exercice} \textbf{Réallocation dynamique (optionnel)}

  Reprenez les trois premiers exercices en ajoutant une réallocation dynamique
  des objets dans la fonction d'accès. Le comportement de cette fonction doit
  alors être le suivant :
  \begin{itemize}
  \item si les indices sont dans les bornes de l'objet retourner le pointeur
    d'accès au bon élément;
  \item si un des indices dépasse les bornes de l'objet tenter de réallouer
    plus de mémoire et renvoyer le pointeur d'accès au bon élément si la
    réallocation réussit et \verb~abort()~ sinon.
  \end{itemize}
  
  Pour la réallocation, on pourra utiliser au choix un \texttt{malloc} d'un
  bloc plus gros suivi d'une copie ou bien l'appel système \texttt{realloc}
  dont on obtient la description avec la commande \run{man 3 realloc}.

  Complétez \file{vecteur\_dynamique.c}, \file{matrice\_dynamique.c} et
  \file{matrice\_lineaire\_dynamique.c}.
\end{Exercice}

\begin{Exercice}\textbf{Opérations mémoire (optionnel)}
Implémentez les fonctions de manipulation mémoire suivantes :
\begin{itemize}
\item \texttt{my\_memcpy} : copie d'une zone en mémoire de la même manière que
  \texttt{memcpy} (cf. man);
\item \texttt{my\_memmove} : copie d'une zone en mémoire avec recouvrement
  possible.  (cf. \texttt{man memmove});
\item \texttt{is\_little\_endian} : renvoie vrai si l'architecture cible
  utilise la convention \textit{little endian} pour la représentation des entiers en
  mémoire;
\item \texttt{reverse\_endianess} : renvoie la valeur passée en argument avec
  ses octets inversé.
\end{itemize}
  Le fichier à compléter est \file{memory\_operations.c}. 
\end{Exercice}
\end{document}
